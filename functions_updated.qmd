---
title: "function_updated"
author: "Jasmine Cabrera"
format: html
editor: visual
---

# Functions (Updated: 02/01/2026)

## Libraries & Parallelization

```{r}
library(tidyclust)
library(tidyverse)
library(tidymodels)
library(foreach)
library(doParallel)
library(MASS)

doParallel::registerDoParallel(cores = detectCores() - 5)
```

## Functions

### **simulate_mvn()**

```{r}
simulate_mvn <- function(n = 100, 
                         covariance = 0.4,
                         desired_k = 3,
                         start_seed = 123){
  
  set.seed(start_seed)
  
  # creating covariance matrix
  cov_matrix <- diag(2) * covariance
  
  # if desired k is wanted
  if (!is.null(desired_k) && desired_k > 0)  {
    
    # obs per cluster
    n_per_cluster <- ceiling(n / desired_k)
    
    # distance between each cluster center
    separation <- 3
    
    # create grid coordinates for means
    grid_coords <- expand.grid(x = seq(0, 
                                       by = separation,
                                       length.out = ceiling(sqrt(desired_k))),
                               y = seq(0, 
                                       by = separation, 
                                       length.out = ceiling(sqrt(desired_k))))
    
    # pick first k grid points
    centers <- grid_coords[1:desired_k, ]
    
    # generate data
    data <- do.call(rbind, lapply(1:desired_k, function(k){
      
      # determine mean
      mu <- c(centers$x[k], centers$y[k])
      
      # generate clusters
      MASS::mvrnorm(n = n_per_cluster,
                    mu = mu,
                    Sigma = cov_matrix)}))

  
  # if no desired kvalue
  }else{
    # mu
    mu <- c(0, 0)
    
    # data
    data <- MASS::mvrnorm(n = n,
                         mu = mu,
                         Sigma = cov_matrix)}
  
  # change to dataframe
  data <- as.data.frame(data)
  
  # standardize
  data <- data |>
  dplyr::mutate(across(c(V1, V2), ~ (. - mean(.)) / sd(.)))
  
  # change col names
  colnames(data) <- c("V1", "V2")
  
  return(data)}
```

------------------------------------------------------------------------

### **buddies_matrix()**

```{r}
buddies_matrix <- function(data = data, 
                           k = 3,
                           subsample_prop = 0.8, 
                           num_subsamples = 10,
                           start_seed = 123){
  
  # drop na
  data <- data |>
    drop_na()
  
  # add index
  data$index <- 1:nrow(data)
  
  # initialize results list -- holds matrix for each subsample in each k
  results <- list()


  results <- foreach(i = 1:num_subsamples,
                     .packages = c("tidyclust", 
                                   "tidyverse", 
                                   "tidymodels")) %dopar% {

                       # initalizing blank matrix              
                       result_matrix <- matrix(0, 
                                               nrow = nrow(data),
                                               ncol = nrow(data))
                       
                       # seed
                       set.seed(start_seed + i)
                     
                       # resample
                       random_sample <- data |>
                         filter(index %in% sample(index, subsample_prop * nrow(data))) 
                       
                       # kmeans
                       kmodel <- k_means(num_clusters = k) |>
                         fit(~ random_sample[[1]] + random_sample[[2]],
                             data = random_sample)

                       
                       # assign points to cluster
                       intermediate <- data.frame(random_sample$index,
                                                  extract_cluster_assignment(kmodel) |>
                                                  mutate(.cluster = as.character(.cluster)),
                                                  stringsAsFactors = FALSE)
                       
                       # rename columns
                       colnames(intermediate) <- c("index", "cluster")
                       
                      # assign results matrix (-1, 1, 0)
                      for (c in unique(intermediate$cluster)){
                        idx <- intermediate[intermediate$cluster == c, ]$index
                        
                        if (length(idx) > 1){
                          idx <- sort(unlist(idx), method = "radix")
                          ones <- t(combn(idx, 2))
                          result_matrix[ones[, 1], ones[, 2]] <- 1}

                        neg_one_idx <- expand.grid(idx, setdiff(random_sample$index, idx))
                        result_matrix[neg_one_idx[, 1], neg_one_idx[, 2]] <- -1}
                     
                      # set lower triangle and diagonal to NA
                      result_matrix[lower.tri(result_matrix, diag = TRUE)] <- NA
                      
                    
                      return(result_matrix)}
                    
  # return results
  return(results)}
```

------------------------------------------------------------------------

### **mean_matrix()**

```{r}
mean_matrix <- function(data = data,
                          k = 3,
                          subsample_prop = 0.8,
                          num_subsamples = 10,
                          start_seed = 123){
  
  # call simulate_cluster() function
  results <- buddies_matrix(data, 
                              k = k,
                              subsample_prop = subsample_prop, 
                              num_subsamples = num_subsamples,
                              start_seed = start_seed)
  
  # abs value the entire matrix for all matrices
  absolute_sum <- lapply(results, abs)
  
  # get sum of abs value in final matrix
  absolute_final <- absolute_sum |>
    reduce(`+`)
  
  # get sum of values in final matrix
  numerator <- results |>
    reduce(`+`)
  
  return(list(matrices = results, score = numerator/absolute_final))}
```

------------------------------------------------------------------------

### **similarity_score()**

```{r}
similarity_score <- function(mean_matrix = mean_matrix){
  
  # get score matrix
  mean_matrix_score <- mean_matrix$score 
  
  # transforms into vector
  result_vector <- as.vector(mean_matrix_score)
  
  # keeps only non NA values
  result_vector <- abs(result_vector[!is.na(result_vector)])
  
  # finds squared distance from one
  return(sum((1 - result_vector)**2))}
```

------------------------------------------------------------------------

### crab()

```{r}
crab <- function(data,
                  n = 100, 
                  min_k = 2,
                  max_k = 5,
                  subsample_prop = 0.8, 
                  num_subsamples = 10,
                  start_seed = 123){
  
  # intialize score list
  k_scores <- data.frame(k = numeric(),
                         score = numeric(),
                         time = numeric(),
                         best_clust = character())
  
  # iterate over k values
  for (k in min_k:max_k){
    
      # start time
      tictoc::tic()
    
      # get buddies matrices and overall mean matrix
      mean_matrix <- mean_matrix(data = data, 
                                 k = k, 
                                 subsample_prop = subsample_prop, 
                                 num_subsamples = num_subsamples, 
                                 start_seed = start_seed)
      
      # store all scores
      score <- similarity_score(mean_matrix = mean_matrix)
      
      # end time
      time_info <- tictoc::toc(quiet = TRUE)
      
      # calculate execution time
      elapsed_time <- time_info$toc - time_info$tic
      
      # add to results
      k_scores <- rbind(k_scores,
                        data.frame(k = k,
                                   score = score,
                                   time = elapsed_time,
                                   best_clust = ""))}
      
  # find row with lowest score 
  best_score_idx <- which.min(k_scores$score)
  k_scores$best_clust[best_score_idx] <- "BEST"
  
  # get similarity score
  return(k_scores)}
```

------------------------------------------------------------------------

### repeat_simulations()

```{r}
repeat_simulations <- function(crab_setup = NULL,
                               data = NULL,
                               num_runs,
                               n = 100,
                               covariance, 
                               desired_k = 3, 
                               min_k,
                               max_k,
                               subsample_prop = 0.8, 
                               num_subsamples,
                               start_seed = 123) {
  
  if (!is.null(crab_setup)){
    # assign data
    sim_data <- crab_setup$data
    
    # check params
    if (is.null(crab_setup$specified_params)){
      stop("Error: You have not specified your parameters. Call crab_sim_params() first.")}
    
    # assign params
    params <- crab_setup$specified_params
    num_runs = params$num_runs
    n = params$n
    covariance = params$covariance
    desired_k = params$desired_k 
    min_k = params$min_k
    max_k = params$max_k
    subsample_prop = params$subsample_prop
    num_subsamples = params$num_subsamples}
  
  # initialize results list
  results_list <- list()
  
  # create counter
  counter <- 1
  
  # loop through covariances
  for (cov in covariance) {
    
     # simulate data
      if (is.null(data)) {
          sim_data <- simulate_mvn(n = n,
                         covariance = cov, 
                         desired_k = desired_k)}
    
    # loop through number of runs/reps
    for (i in seq_len(num_runs)) {
      
      # alternate seed
      current_seed <- start_seed + i
      
      # call crab()
      sim_result <- crab(data = sim_data,
                         start_seed = current_seed,
                         n = n,
                         min_k = min_k,
                         max_k = max_k,
                         subsample_prop = subsample_prop, 
                         num_subsamples = num_subsamples)
      
      # add rep identifier
      sim_result$run <- i
      
      # add covariance identifier
      sim_result$cov <- cov
      
      # store result
      results_list[[counter]] <- sim_result
      
      # increase counter
      counter <- counter + 1}}
  
  # combine all results
  all_results <- do.call(rbind, results_list)
  return(all_results)}
```

------------------------------------------------------------------------

### crab_prep()

```{r}
crab_prep <- function(data){
  # grab all columns, leave user choices NULL
  data_info <- list(data = data, 
                    original_cols = colnames(data),
                    specified_cols = NULL,
                    specified_params = NULL)
  
  return(data_info)}
```

------------------------------------------------------------------------

### crab_cols()

```{r}
crab_cols <- function(data_info, chosen_cols){
  # check if chosen columns exist
  missing_cols <- setdiff(chosen_cols, data_info$original_cols)
  
  # leave error message if columns dont exist
  if (length(missing_cols) > 0) {
    stop("Column(s) do not exist: ",
         paste(missing_cols, collapse = ", "))}
  
  # update specified cols
  data_info$specified_cols <- chosen_cols
  
  return(data_info)}
```

------------------------------------------------------------------------

### crab_params()

```{r}
crab_params <- function(data_info, min_k, max_k, num_subsamples, 
                        n = 100, subsample_prop = 0.8){
  # check min_k and max_k
  if (min_k > max_k){
    stop("Error: min_k must be <= max_k.")}
    
  # check subsample prop
  if (subsample_prop >= 1){
    stop("Error: subsample_prop must be < 1.")}
  
  # update specified params
  data_info$specified_params <- list(
    min_k = min_k,
    max_k = max_k,
    num_subsamples = num_subsamples,
    n = n,
    subsample_prop = subsample_prop)
  
  return(data_info)}
```

------------------------------------------------------------------------

### crab_sim_params()

```{r}
crab_sim_params <- function(data_info, min_k, max_k, num_subsamples, 
                            n = 100, covariance, desired_k = 3, 
                            subsample_prop = 0.8, num_runs){
  # check min_k and max_k
  if (min_k > max_k){
    stop("Error: min_k must be <= max_k.")}
    
  if (min_k < 0){
    stop("Error: min_k must be > 0.")}
  
  if (max_k < 0){
    stop("Error: max_k must be > 0.")}
  
  # check subsample prop
  if (subsample_prop >= 1){
    stop("Error: subsample_prop must be < 1.")}
  
  # check num_runs
  if (num_runs < 0){
    stop("Error: num_runs must be > 0.")}
  
  # update specified params
  data_info$specified_params <- list(
    min_k = min_k,
    max_k = max_k,
    num_subsamples = num_subsamples,
    n = n,
    covariance = covariance,
    desired_k = desired_k,
    subsample_prop = subsample_prop,
    num_runs = num_runs)
  
  return(data_info)}
```

------------------------------------------------------------------------

### crab_bake()

```{r}
crab_bake <- function(data_info){
  # check cols are chosen
  if (is.null(data_info$specified_cols)){
    stop("No columns have been specified. Call crab_cols() first.")}
  
  # check params are chosen
  if (is.null(data_info$specified_params)){
    stop("No parameters have been specified. Call crab_params() first.")}

  # grab data with chosen cols
  crab_data <- data_info$data[, data_info$specified_cols, drop = FALSE]
  
  # grab params
  params <- data_info$specified_params
  
  # call crabs 
  score <- crab(data = crab_data,
                n = params$n,
                covariance = params$covariance,
                desired_k = params$desired_k,
                min_k = params$min_k,
                max_k = params$max_k,
                subsample_prop = params$subsample_prop,
                num_subsamples = params$num_subsamples)
  
  return(score)}
```
